## 二叉树
### 二叉树定义

1. 每个节点只能有左右两节点
2. 左节点一定小于根节点
3. 右节点一定大于根节点
4. 支持快速查找、插入、删除操作

#### 查找操作

- 如果小于根节点，向左节点查找
- 如果大于根节点，向右节点查找
- 最终当查找值等于节点值时，返回节点

#### 插入操作

- 如果小于根节点，向左节点插入
- 如果左节点有值，重复进行比较
- 右节点插入同理

#### 删除操作

1. 要删除的节点没有子节点
- 直接删除当前节点
2. 要删除的节点有一个子节点
- 将子节点与根节点替换
- 删除子节点（原根节点）
3. 要删除的节点有两个子节点
- 查找右节点中的最小节点
- 保证最后形成的树依旧是所有的左节点小于根节点，右节点大于根节点

#### 快速查找最大节点

#### 快速查找最小节点

#### 快速查找前驱节点

#### 快速查找后继节点

#### 支持重复数据的二叉查找树

两种方法

1. 每一个节点不光存储一个值，可以换成存储链表和动态扩容的数组
2. 每个节点仅存储一个值
- 插入位置的时候，把这个值放到这个值的右子树中，作为大于该值的值来进行存储。
- 查找该值时，遇到相同值的节点的时候继续向下查找。就可以把等于这个键值的所有节点都查出来。

### 二分查找

#### 二分查找步骤

1、定位一个头指针，定位一个尾指针，将头指针与尾指针的中位数指针与给定值进行比对，

2、如果小于给定值，尾指针后退到中位数指针的前一位。

3、如果大于给定值，头指针前进到中位数指针的后一位。

4、然后再进行比对，直到中位数指针与给定值相等为止。

#### 具体代码实现

```
    public int bsearchForFirstValue(int[] a, int n, int value) {
        //设置低指针
        int low = 0;
        //设置高指针
        int high = n - 1;
        //当且仅当低指针<=高指针位置时
        while (low <= high) {
            //获取二分查找的中位数指针的值(括号内的意思是，高位减去低位除以2，如果不是整数，选取右边第一位)
            int mid =  low + ((high - low) >> 1);
            //当中位数指针大于给定值时，说明在小区间，则大指针挪到中位数前一位
            if (a[mid] > value) {
                high = mid - 1;
            //当小于时，说明在大区间，则小指针挪到中位数的后一位
            } else if (a[mid] < value) {
                low = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
```

### 二分查找变形

1、如果有序数组中存在多个相等值，且给定值与多个值相等，则返回的数值就不一定是某个固定数值了。为了保证返回到第一个数值（或最后一个数值），则需要判断mid指针的前一位（或后一位）与当前值是否相等。如若相等，则大指针缩小（或小指针增大）来缩小查找范围，从而确定所需要获取的值。